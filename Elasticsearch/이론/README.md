## Elasticsearch 정리

Elasticsearch 이론을 정리한 곳

---

### 📌 Elasticsearch란?

- Apache Lucene(루씬)
- 역색인 구조
- RESP API 지원
- 오픈소스 **검색엔진**


<br/>

**용어 정리**
|Elasticsearch|RDBMS|
|---|----|
|인덱스|데이터베이스|
|문서(document)|로우|
|필드(field)|칼럼|
|Query DSL|SQL|

**구성**

![Frame 2](https://user-images.githubusercontent.com/87689191/226813788-9e928e51-61b7-43ff-9fbb-f215b613a6c0.png)

- 클러스터 (Docker)
- 3개의 노드
    - [docker-compose.yml 참고](https://github.com/unhas01/Book-Pub/tree/main/Elasticsearch/%EC%84%A4%EC%A0%95)
- 노드 속에 샤드

![Frame 4](https://user-images.githubusercontent.com/87689191/226819289-b370519a-a6bf-4c3b-bf30-bcc2d2362880.png)

- 샤드 속엔 하나의 루씬
    - 루씬 기반
- 루씬 속에는 Segment(세그먼트)단위로 구성

---

### 📌 루씬?

Elasticsearch를 보기전 루씬을 먼저 정리하고 넘어감

- 샤드 속에는 `루씬` 라이브러리가 존재
- Java 기반
- 루씬 속에는 `세그먼트`들이 존재
    - 세그먼트 역시도 역색인 구조
- 단점
    - 루씬은 물리 머신이 제공하는 리소스의 한계를 넘을 수 없다는 한계 
    - 엘라스틱서치는 샤드 무한 확장이 가능하도록 설계

<br/>

**원리**
- 2개의 핵심 함수
    - `indexWriter()`
    - `indexSearcher()`
- 오로지 색인과 검색 역할

<br/>

![image](https://user-images.githubusercontent.com/87689191/226840569-0d97c357-cee6-4be3-8a56-639031968cd6.png)

1. 색인 요청이 들어오면 `writer()`에서 색인 후 하나의 **세그먼트** 생성
2. 주기적으로 세그먼트를 `merge()` 함으로써 세그먼트 개수는 줄어 결국 하나로 함쳐짐
    - 성능 향상을 위해 주기도 설정 가능
    - 최종 세그먼트 개수도 설정 가능

<br/>

**루씬 특징**
이렇게 복잡하게 합치는 과정이 있는 이유?

- 우선 세그먼트는 수정이 불가능하게 설정이 되어 있음
    - 불변성을 **보장**
- `merge()`전 까지는 수정이 전혀 이루어 지지 않음
- 불변성이 주는 장점
    - 동시성 문제 회피
        - 불변성이 보장되기 때문에 `Lock`이 필요 없고, 멀티 스레드 환경에서 동시성 문제를 신경 쓰지 않아도 됨
    - 시스템 캐시 활용가능
        - 캐시를 삭제할 일이 없기 때문에 캐시를 적극 활용 가능
    - 높은 캐시 적중률
        - 캐시의 수명이 길어짐
    - 리소스 절감
        - 역색인 과정은 많은 리소스(CPU, I/O)가 사용됨
- 데이터가 삭제되거나 수정인 경우?
    - 데이터가 있는 세그먼트에 `flag`를 삭제로 표시 후 `merge()`시점에 삭제를 진행하면서 삭제
    - 수정은 삭제 과정을 진행 후 새로운 세그먼트를 생성
    - 즉 **수정**은 없음

---

### 📌 이어서 다시 Elasticsearch

루씬을 활용하는 엘라스틱서치를 이어서 정리

- 위 구성 이미지를 보면 엘라스틱서치는 `Shard(샤드)`단위에 저장
- 샤드에는 `Primary Shard(원본)`, `Replica Shard(복제본)`가 존재
    - <b style="color: red;">같은 노드에는 절대 원본과 복제본이 공존하지 않음</b>
- 원본과 복제본의 존재 이유?
    - 보험용
        - 하나의 샤드를 어느 이유로 손실이 되어도 복제본이 있으면 데이터를 잃지 않은 상황과 결국 동일함
    - 검색 속도 향상
- 샤드의 개수(원본, 복제본)는 추후 재설정이 불가능함
    - 이유는 루씬과 연관이 있음
    - 루씬 내부의 각 세그먼트들은 다른 샤드의 루씬의 정보를 알 수가 없음
    - 그렇기에 수정이 불가능함
- 샤드 개수 설정
    - 하나의 샤드에 20GB ~ 40GB를 유지하는 것을 권장
    - 샤드 개수가 큰 경우
        - 검색 속도 향상
        - 색인 속도 저하
    - 샤드 개수가 작은 경우
        - 검색 속도 저하
        - 색인 속도 향상
    - 즉, `Trade Off`

<br/>

**역색인 구조**
- 세그먼트와 엘라스틱서치는 역색인 구조임

![image](https://user-images.githubusercontent.com/87689191/226906444-d702e22a-d67c-4d42-9957-04d57cd70417.png)

- 위와 같은 형식으로 데이터들이 저장
- 색인 과정 중에 설정한 `토크나이저`, `필터`를 거친 데이터들이 저장
- 역색인 구조 장점
    1. 키워드 검색 가능
    1. 검색 속도가 빠름
        - 색인 구조에서 검색 속도 : `O(N)`
        - 역색인 구조에서 검색 속도 : `O(log N)`








